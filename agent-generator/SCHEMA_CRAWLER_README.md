# Schema Crawler Tool - Complete Guide

> **Automated JSON Schema → Zod + TypeScript generator for MCP tool type safety**

**Location**: `agent-generator/src/mcp-registry/schema-crawler.ts`  
**Purpose**: Transform MCP tool JSON Schemas into Zod validation schemas and TypeScript types  
**Tech Stack**: TypeScript 5, Zod 3.x

---

## What Does This Tool Do?

The **schema-crawler** automates the tedious and error-prone process of:

1. **Converting JSON Schemas** (from MCP tool definitions) into **Zod validation schemas**
2. **Generating TypeScript interfaces** that match the schemas
3. **Creating runtime validators** for safe data parsing
4. **Producing complete modules** ready to import in your codebase

---

## Key Capabilities

| Feature                | Description                                              |
| ---------------------- | -------------------------------------------------------- |
| **JSON Schema → Zod**  | Converts JSON Schema objects into Zod schema code        |
| **TypeScript Types**   | Generates matching TypeScript interfaces                 |
| **Runtime Validation** | Creates `validate()` and `validateSafe()` functions      |
| **Complex Types**      | Handles objects, arrays, enums, nested structures        |
| **Constraints**        | Preserves min/max length, regex patterns, numeric bounds |
| **Batch Processing**   | Generates modules for multiple tools at once             |
| **File Structure**     | Creates complete directory structure with barrel exports |

---

## Core Functions

### 1. `generateZodFromJSONSchema()`

**Purpose**: Main entry point - converts JSON Schema to Zod + types

```typescript
import { generateZodFromJSONSchema } from "./schema-crawler";

const jsonSchema = {
  type: "object",
  properties: {
    name: { type: "string", minLength: 1 },
    age: { type: "integer", minimum: 0 },
  },
  required: ["name"],
};

const result = generateZodFromJSONSchema(jsonSchema, "Person");

console.log(result.zodCode);
// z.object({
//   name: z.string().min(1),
//   age: z.number().int().min(0).optional(),
// })

console.log(result.typeDefinition);
// export interface Person {
//   name: string;
//   age?: number;
// }

console.log(result.validatorCode);
// export function validatePerson(input: unknown): Person {
//   return PersonSchema.parse(input);
// }
```

**Returns**: `ZodSchemaOutput` with:

- `zodCode`: Raw Zod schema as string
- `typeDefinition`: TypeScript interface
- `validatorCode`: Validation functions

---

### 2. `generateZodModule()`

**Purpose**: Generate complete TypeScript module with imports, types, and validators

```typescript
import { generateZodModule } from "./schema-crawler";

const inputSchema = {
  type: "object",
  properties: {
    city: { type: "string", minLength: 2 },
    units: { type: "string", enum: ["celsius", "fahrenheit"] },
  },
  required: ["city"],
};

const outputSchema = {
  type: "object",
  properties: {
    temperature: { type: "number" },
    condition: { type: "string" },
  },
};

const module = generateZodModule("getWeather", inputSchema, outputSchema);

console.log(module);
```

**Output**:

```typescript
/**
 * Auto-generated by schema-crawler.ts
 * MCP Tool: getWeather
 */

import { z } from "zod";

/* ==================== INPUT ==================== */

export interface getWeatherInput {
  city: string;
  units?: "celsius" | "fahrenheit";
}

export const getWeatherInputSchema = z.object({
  city: z.string().min(2),
  units: z.enum(["celsius", "fahrenheit"]).optional(),
});

export function validategetWeatherInput(input: unknown): getWeatherInput {
  return getWeatherInputSchema.parse(input);
}

export function validategetWeatherInputSafe(input: unknown): Result<getWeatherInput, ZodError> {
  return getWeatherInputSchema.safeParse(input);
}

/* ==================== OUTPUT ==================== */

export interface getWeatherOutput {
  temperature: number;
  condition: string;
}

export const getWeatherOutputSchema = z.object({
  temperature: z.number(),
  condition: z.string(),
});

export function validategetWeatherOutput(input: unknown): getWeatherOutput {
  return getWeatherOutputSchema.parse(input);
}

export function validategetWeatherOutputSafe(input: unknown): Result<getWeatherOutput, ZodError> {
  return getWeatherOutputSchema.safeParse(input);
}

/* ==================== TOOL DEFINITION ==================== */

export const getWeatherTool = {
  name: "getWeather",
  inputSchema: getWeatherInputSchema,
  outputSchema: getWeatherOutputSchema,
} as const;
```

---

### 3. `generateZodModulesBatch()`

**Purpose**: Process multiple tools at once

```typescript
import { generateZodModulesBatch } from "./schema-crawler";

const tools = [
  {
    name: "getWeather",
    inputSchema: {
      /* ... */
    },
    outputSchema: {
      /* ... */
    },
  },
  {
    name: "translateText",
    inputSchema: {
      /* ... */
    },
    outputSchema: {
      /* ... */
    },
  },
];

const modules = generateZodModulesBatch(tools);

// Map<string, string>
// Key: "getWeather" → Value: full module code
// Key: "translateText" → Value: full module code

modules.forEach((code, toolName) => {
  console.log(`Generated module for ${toolName}`);
});
```

---

### 4. `generateSchemaFileStructure()`

**Purpose**: Create complete directory structure with barrel exports

```typescript
import { generateSchemaFileStructure } from "./schema-crawler";

const tools = [
  { name: "getWeather", inputSchema: {}, outputSchema: {} },
  { name: "translateText", inputSchema: {}, outputSchema: {} },
];

const files = generateSchemaFileStructure("weather-mcp", tools);

// files = Map<string, string>
// "weather-mcp/getWeather.schema.ts" → module code
// "weather-mcp/translateText.schema.ts" → module code
// "weather-mcp/index.ts" → barrel export
// "weather-mcp/registry.ts" → tool registry

files.forEach((content, filePath) => {
  fs.writeFileSync(filePath, content);
});
```

**Generated File Structure**:

```
weather-mcp/
├── getWeather.schema.ts      # Zod schema + types for getWeather
├── translateText.schema.ts   # Zod schema + types for translateText
├── index.ts                  # Barrel export: export * from './getWeather.schema'
└── registry.ts               # Tool registry with all tools
```

**registry.ts Example**:

```typescript
/**
 * weather-mcp - Auto-generated schemas
 *
 * This file contains Zod schemas for all tools provided by the weather-mcp MCP server.
 * All types are generated from the server's JSON Schema definitions.
 */

import * as schemas from "./index";

export const weather_mcpTools = {
  getWeather: schemas.getWeatherTool,
  translateText: schemas.translateTextTool,
} as const;

export type weather_mcpToolNames = keyof typeof weather_mcpTools;
```

---

## Supported JSON Schema Features

### Basic Types

| JSON Schema Type | Zod Schema         |
| ---------------- | ------------------ |
| `string`         | `z.string()`       |
| `number`         | `z.number()`       |
| `integer`        | `z.number().int()` |
| `boolean`        | `z.boolean()`      |
| `array`          | `z.array()`        |
| `object`         | `z.object()`       |
| `null`           | `z.null()`         |

### String Constraints

```json
{
  "type": "string",
  "minLength": 5,
  "maxLength": 50,
  "pattern": "^[A-Z]"
}
```

↓

```typescript
z.string()
  .min(5)
  .max(50)
  .regex(/^[A-Z]/);
```

### Number Constraints

```json
{
  "type": "integer",
  "minimum": 0,
  "maximum": 100
}
```

↓

```typescript
z.number().int().min(0).max(100);
```

### Enums

```json
{
  "type": "string",
  "enum": ["small", "medium", "large"]
}
```

↓

```typescript
z.enum(["small", "medium", "large"]);
```

### Objects with Required/Optional Fields

```json
{
  "type": "object",
  "properties": {
    "name": { "type": "string" },
    "age": { "type": "integer" }
  },
  "required": ["name"]
}
```

↓

```typescript
z.object({
  name: z.string(),
  age: z.number().int().optional(),
});
```

### Arrays

```json
{
  "type": "array",
  "items": { "type": "string" }
}
```

↓

```typescript
z.array(z.string());
```

### Nested Objects

```json
{
  "type": "object",
  "properties": {
    "user": {
      "type": "object",
      "properties": {
        "name": { "type": "string" },
        "email": { "type": "string" }
      }
    }
  }
}
```

↓

```typescript
z.object({
  user: z
    .object({
      name: z.string(),
      email: z.string(),
    })
    .optional(),
});
```

---

## Real-World Usage Example

### Step 1: Define MCP Tool with JSON Schema

```python
# agent/tools.py (Python MCP server)
from mcp.server.fastmcp import FastMCP
from pydantic import BaseModel, Field

class WeatherInput(BaseModel):
    city: str = Field(min_length=2, max_length=100)
    units: str = Field(pattern="^(celsius|fahrenheit)$")

@mcp.tool()
def get_weather(params: WeatherInput) -> dict:
    """Get weather for a city"""
    # Implementation
    pass
```

### Step 2: Extract JSON Schema

```json
{
  "type": "object",
  "properties": {
    "city": {
      "type": "string",
      "minLength": 2,
      "maxLength": 100
    },
    "units": {
      "type": "string",
      "enum": ["celsius", "fahrenheit"]
    }
  },
  "required": ["city"]
}
```

### Step 3: Run schema-crawler

```typescript
import { generateZodModule } from "./schema-crawler";
import fs from "fs";

const inputSchema = {
  type: "object",
  properties: {
    city: { type: "string", minLength: 2, maxLength: 100 },
    units: { type: "string", enum: ["celsius", "fahrenheit"] },
  },
  required: ["city"],
};

const module = generateZodModule("getWeather", inputSchema);

fs.writeFileSync("schemas/getWeather.schema.ts", module);
```

### Step 4: Use Generated Schema in Your Code

```typescript
// frontend/lib/tools.ts
import { getWeatherInputSchema, validategetWeatherInput } from "@/schemas/getWeather.schema";

function callWeatherTool(userInput: unknown) {
  try {
    // Runtime validation
    const validInput = validategetWeatherInput(userInput);

    // Now TypeScript knows validInput is { city: string; units?: string }
    console.log(`Fetching weather for ${validInput.city}`);

    // Safe to call MCP tool
    return mcpClient.call("getWeather", validInput);
  } catch (error) {
    console.error("Invalid weather input:", error);
    throw new Error("Please provide a valid city name");
  }
}

// Usage
callWeatherTool({ city: "London", units: "celsius" }); // ✅ Valid
callWeatherTool({ city: "L" }); // ❌ Fails: minLength 2
callWeatherTool({ city: "Paris", units: "kelvin" }); // ❌ Fails: not in enum
```

---

## Integration with ModMe GenUI Workbench

### Use Case: Validate Agent Tool Calls

```typescript
// src/app/api/copilotkit/route.ts
import {
  upsertUIElementInputSchema,
  validateupsertUIElementInput,
} from "@/schemas/agent-tools.schema";

export async function POST(req: Request) {
  const body = await req.json();

  // Validate tool calls before forwarding to Python agent
  if (body.tool === "upsert_ui_element") {
    try {
      const validParams = validateupsertUIElementInput(body.params);
      // Forward to agent
      return fetch("http://localhost:8000/", {
        method: "POST",
        body: JSON.stringify({ tool: body.tool, params: validParams }),
      });
    } catch (error) {
      return new Response(JSON.stringify({ error: "Invalid parameters" }), {
        status: 400,
      });
    }
  }
}
```

### Use Case: Type-Safe Component Props

```typescript
// src/components/registry/StatCard.tsx
import { StatCardPropsSchema } from "@/schemas/StatCard.schema";

export function StatCard(rawProps: unknown) {
  const result = StatCardPropsSchema.safeParse(rawProps);

  if (!result.success) {
    console.error("StatCard validation failed:", result.error);
    return <ErrorFallback />;
  }

  const { title, value, trend } = result.data;
  // TypeScript knows exact types here
}
```

---

## Benefits

### 1. Type Safety Across Python ↔ TypeScript

```python
# Python defines schema
@mcp.tool()
def my_tool(city: str, units: str) -> WeatherData:
    pass
```

```typescript
// TypeScript gets matching types automatically
const input: MyToolInput = { city: "Paris", units: "celsius" };
validateMyToolInput(input); // Runtime validation
```

### 2. Prevents Runtime Errors

```typescript
// Without schema-crawler:
const data = { city: "L" }; // Too short, but no validation
mcpClient.call("getWeather", data); // ❌ Fails at runtime in Python

// With schema-crawler:
const data = { city: "L" };
validategetWeatherInput(data); // ✅ Fails immediately with clear error message
```

### 3. Auto-Generated Documentation

Generated TypeScript interfaces serve as inline documentation:

```typescript
export interface getWeatherInput {
  /** City name (2-100 characters) */
  city: string;
  /** Temperature units (celsius or fahrenheit) */
  units?: "celsius" | "fahrenheit";
}
```

### 4. Refactoring Safety

When you change Python schemas, regenerate TypeScript schemas:

```bash
npm run generate:schemas  # Regenerates all schemas
npm run typecheck         # TypeScript catches breaking changes
```

---

## Advanced Features

### Custom Equality Checks

```typescript
// Generated schema includes custom comparators
const schema1 = getWeatherInputSchema;
const schema2 = getWeatherInputSchema;

console.log(schema1 === schema2); // true (referential equality)
```

### Structured Error Messages

```typescript
const result = validategetWeatherInputSafe({ city: "L", units: "kelvin" });

if (!result.success) {
  console.log(result.error.issues);
  // [
  //   { path: ["city"], message: "String must contain at least 2 character(s)" },
  //   { path: ["units"], message: "Invalid enum value. Expected 'celsius' | 'fahrenheit'" }
  // ]
}
```

### Schema Composition

```typescript
// Combine generated schemas
import { getWeatherInputSchema } from "./getWeather.schema";
import { z } from "zod";

const extendedSchema = getWeatherInputSchema.extend({
  includeHourly: z.boolean().optional(),
});
```

---

## Limitations

| Limitation                        | Workaround                                     |
| --------------------------------- | ---------------------------------------------- |
| **$ref (JSON Schema references)** | Limited support - flatten schemas first        |
| **oneOf/anyOf/allOf**             | Not fully supported - use union types manually |
| **Custom formats**                | Add manual refinements after generation        |
| **Conditional schemas**           | Use Zod's `.refine()` after generation         |

---

## Comparison with Alternatives

| Tool                         | JSON Schema Support | TypeScript Generation | Runtime Validation | Complexity |
| ---------------------------- | ------------------- | --------------------- | ------------------ | ---------- |
| **schema-crawler**           | ✅ Good             | ✅ Full               | ✅ Zod             | Simple     |
| **json-schema-to-zod**       | ✅ Full             | ⚠️ Partial            | ✅ Zod             | Medium     |
| **quicktype**                | ⚠️ Partial          | ✅ Full               | ❌ None            | High       |
| **ts-json-schema-generator** | ✅ Full             | ✅ Full               | ❌ None            | High       |

**Why schema-crawler?**

- Optimized for MCP tool schemas
- Generates both types AND runtime validators
- Simple API, minimal dependencies
- Integrated with GenUI workbench patterns

---

## Quick Reference

### Main Functions

```typescript
// 1. Convert single schema
const result = generateZodFromJSONSchema(jsonSchema, "SchemaName");

// 2. Generate complete module
const module = generateZodModule("toolName", inputSchema, outputSchema);

// 3. Batch process
const modules = generateZodModulesBatch(tools);

// 4. Generate file structure
const files = generateSchemaFileStructure("serverName", tools);

// 5. Generate barrel export
const index = generateBarrelExport(["tool1", "tool2"]);
```

### Type Mapping

```typescript
JSON Schema          →  Zod                        →  TypeScript
---------------------------------------------------------------
"string"             →  z.string()                 →  string
"number"             →  z.number()                 →  number
"integer"            →  z.number().int()           →  number
"boolean"            →  z.boolean()                →  boolean
"array"              →  z.array(z.string())        →  string[]
"object"             →  z.object({ ... })          →  { ... }
enum: ["a", "b"]     →  z.enum(["a", "b"])         →  "a" | "b"
minLength: 5         →  z.string().min(5)          →  string
maximum: 100         →  z.number().max(100)        →  number
pattern: "^[A-Z]"    →  z.string().regex(/^[A-Z]/) →  string
```

---

## Future Enhancements

- [ ] **Full $ref support** - Resolve JSON Schema references
- [ ] **oneOf/anyOf support** - Union/intersection types
- [ ] **Custom validators** - Plugin system for custom refinements
- [ ] **OpenAPI integration** - Generate from OpenAPI specs
- [ ] **CLI tool** - `npx schema-crawler generate ./schemas`
- [ ] **Watch mode** - Auto-regenerate on schema changes

---

## Related Resources

- **Zod Documentation**: <https://zod.dev/>
- **JSON Schema Spec**: <https://json-schema.org/>
- **MCP Protocol**: <https://modelcontextprotocol.io/>
- **ModMe GenUI Docs**: [../docs/](../docs/)

---

## Troubleshooting

### Issue: "Cannot find module 'zod'"

```bash
npm install zod
```

### Issue: Generated code has type errors

- Ensure JSON Schema is valid (test with JSON Schema validator)
- Check for unsupported features (oneOf, $ref)
- Manually refine generated code if needed

### Issue: Schema too complex

- Break into smaller schemas
- Use composition after generation
- Consider manual Zod schema for edge cases

---

**Maintained by**: ModMe GenUI Team  
**Last Updated**: January 2, 2026  
**Version**: 1.0.0
